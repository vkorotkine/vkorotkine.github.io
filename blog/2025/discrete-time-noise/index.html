<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> discretization of continuous-time noise and process models | Vassili Korotkine </title> <meta name="author" content="Vassili Korotkine"> <meta name="description" content="some bees in my bonnet on continuous-time to discrete-time white noise conversion"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://vkorotkine.github.io/blog/2025/discrete-time-noise/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" integrity="sha256-q9ba7o845pMPFU+zcAll8rv+gC+fSovKsOoNQ6cynuQ=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css" integrity="sha256-Oppd74ucMR5a5Dq96FxjEzGF7tTw2fZ/6ksAqDCM8GY=" crossorigin="anonymous" media="screen and (prefers-color-scheme: light)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" integrity="sha256-nyCNAiECsdDHrr/s2OQsp5l9XeY2ZJ0rMepjCT2AkBk=" crossorigin="anonymous" media="screen and (prefers-color-scheme: dark)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/css/diff2html.min.css" integrity="sha256-IMBK4VNZp0ivwefSn51bswdsrhk0HoMTLc2GqFHFBXg=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "discretization of continuous-time noise and process models",
            "description": "some bees in my bonnet on continuous-time to discrete-time white noise conversion",
            "published": "March 20, 2025",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Vassili</span> Korotkine </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/notes/">notes </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>discretization of continuous-time noise and process models</h1> <p>some bees in my bonnet on continuous-time to discrete-time white noise conversion</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#random-processes">Random Processes</a> </div> <div> <a href="#from-continuous-time-covariances-to-discrete-time">From Continuous-Time Covariances to Discrete Time</a> </div> <ul> <li> <a href="#linearize-then-discretize">Linearize Then Discretize</a> </li> <li> <a href="#continuous-to-discrete-time-noise-in-a-vacuum">Continuous to Discrete Time Noise "In A Vacuum"</a> </li> </ul> </nav> </d-contents> <p>Physical systems are continuous. However, we work with discrete-time models that are amenable to digital computers. Therefore, we create continuous models of the physical systems that we then discretize.</p> <p>This becomes particularly interesting in the case of sensor noise, since there is a randomness that needs to be modeled. Typically we use white noise models. However, while the discrete-time white noise model is fairly straightforward (a Gaussian distribution for every noise sample), the continuous-time model is really not, and deriving the transition from continuous to discrete time for white noise is nuanced.</p> <p>A key aspect in this dilemma is that it’s hard to decouple the dynamics of the system we are considering from the random process noise properties. For instance, a gyroscope may have some continuous noise characteristics of its own. Yet, when we consider discrete-time properties, we need to look at the effect of time, and thus the overall system dynamics. This is only really tractable for linear systems (and thus, linearizations).</p> <p>The post is split into three parts. The first part on random processes essentially covers terminology. We go over why the term power spectral density is used interchangeably with continuous-time covariance. The second part covers the “Linearize then Discretize” method, which obtains discretizations by lumping in the effects of system dynamics with effect of random process noise. The first and second parts are essentially summaries of relevant parts of Sec. 4.3.2, 4.4, 4.7 of <d-cite key="farrell2008navigation"></d-cite>. The third part is where things get really interesting. We consider continuous to discrete time noise “in a vacuum” and try to decouple the effect of system dynamics from the random process noise. There is a commonly used formula, which yields good results in practice, but as far there is no completely satisfying way to derive it from first principles. We go through some approaches that have been proposed and discuss them. </p> <h1 id="random-processes">Random Processes</h1> <p>Noise is modeled using random processes in continuous time. A random process $\mathbf{v}(t)$ defines a probability density at every time $t$.</p> <p>The autocovariance of a random process $\mathbf{v}(t)$ is given by \begin{equation} \text{cov}(\mathbf{v}(t_1), \mathbf{v}(t_2))=\mathbb{E}[\mathbf{v}(t_1)\mathbf{v}(t_2)^\text{T}] - \mathbb{E}[\mathbf{v}(t_1)]\mathbb{E}[\mathbf{v}(t_2)^\text{T}]. \end{equation}</p> <p>Essentially we take a bunch of samples at different times $t_1, t_2$, subtract the means at those times, and see how the results vary together.</p> <p>In the context of sensor noise, a commonly used assumption is that noise is a <em>wide sense stationary</em> random process, where the <em>mean</em> and <em>variance</em> of the process are independent of time.</p> <p>For a <em>wide sense stationary</em> process, the autocovariance $\text{cov}(\mathbf{v}(t_1), \mathbf{v}(t_2))$ <em>only</em> depends on the time difference $\tau =t_2-t_1$, \begin{equation} \text{cov}(\mathbf{v}(t_1), \mathbf{v}(t_2))=\mathbf{R}(t_2-t_1) = \mathbf{\tau}. \end{equation}</p> <p>The Power Spectral Density (PSD) of the process is given by \begin{equation} \mathbf{S}(j\omega)=\int_{-\infty}^\infty \mathbf{R}(\tau) \exp (-j\omega \tau) \text{d} \tau. \end{equation}</p> <p>The PSD describes the strength of the random process as different frequencies. For the scalar case, <em>white</em> noise is noise where the PSD is a constant for all frequencies, $\mathbf{S}(j\omega)=\mathbf{S}_w$. Technically, this kind of noise would have infinite power - but this works in practice.</p> <p>Using the inverse Fourier transform, white noise implies that the autocovariance is given by \begin{equation} \mathbf{R}_{\text{white}}(\tau)= \mathbf{S}_w \delta (\tau) = \mathbf{R}_c \delta (\tau). \end{equation} where $\delta(\tau)$ is the Dirac delta. For a long while I was confused by the fact that in sensor datasheets, the PSD is typically stated, and we read it off and use it as the continuous-time covariance for sensor noise. At first glance it does not make sense, since PSD is a frequency domain concept. However, with the assumption of white noise and a few lines of Fourier transforms, the PSD is shown to have the same value as the continuous-time noise covariance, denoted $\mathbf{R}_c$.</p> <h1 id="from-continuous-time-covariances-to-discrete-time">From Continuous-Time Covariances to Discrete Time</h1> <h2 id="linearize-then-discretize">Linearize Then Discretize</h2> <p>Consider a continuous-time system of the form \begin{equation} \dot{\mathbf{x}}=\mathbf{A}_c(t)\mathbf{x}(t)+\mathbf{L}_c(t)\mathbf{w}(t), \quad \mathbf{w}(t) \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_c \delta(\tau)) \end{equation}</p> <p>with $\mathbf{w}(t)$ being white noise, a Gaussian random process with continuous-time covariance $\mathbf{Q}_c$. This system may for instance come from linearization of a nonlinear system. The goal is to find an equivalent discrete-time system of the form</p> <p>\begin{equation} \mathbf{x}_{k+1}=\mathbf{A}_k \mathbf{x}_k + \mathbf{w}_k, \quad \mathbf{w}_k \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_d), \end{equation}</p> <p>which is more tractable to reason about on digital computers. The solution for $\mathbf{A}_k$ is fairly straightforward,</p> <p>\begin{equation} \mathbf{A}_k = \exp(\mathbf{A}_c \Delta t), \end{equation}</p> <p>where $\Delta t$ is the sampling period, and the matrix exponential is used. On the other hand, determining $\mathbf{Q}_d$ requires integration of the continuous-time dynamics to compute the discrete noise $\mathbf{w}_k$,</p> <p>\begin{equation} \mathbf{w}_k = \int_{-\infty}^\infty \exp (\mathbf{A} (t_{k+1}-\tau))\mathbf{L}_c (\tau) \mathbf{w}(\tau)\text{d}\tau \end{equation} The continuous-time covariance $\mathbf{Q}_d$ is then given by \begin{align} \mathbf{Q}_d&amp;=\mathbb{E}[\mathbf{w}_k \mathbf{w}_k^{\text{T}}], \end{align} which, after simplification, becomes </p> <p>\begin{equation} \mathbf{Q}_d = \int_{t_k}^{t_{k+1}} \exp(\mathbf{A_c}(t_{k+1}-\tau)) \mathbf{L}_c \mathbf{Q}_c \mathbf{L}_c^\text{T} \exp(\mathbf{A_c}(t_{k+1}-\tau))^{\text{T}} \text{d} \tau. \end{equation} </p> <p> The resulting $\mathbf{Q}_d$ is thus dependent on how the matrix exponential $\exp(\mathbf{A_c}(t_{k+1}-\tau))$ is computed. In some cases, it can be computed in closed form, giving an exact solution for $\mathbf{Q}_d$. It can also be approximated numerically using a Taylor series. The Taylor series approximation for $\exp(\mathbf{A}\Delta t)$ is given by </p> <p>\begin{equation} \exp(\mathbf{A}\Delta t)=\exp(\mathbf{A}_c\Delta t)=\mathbf{1}+\mathbf{A}_c\Delta t +\frac{1}{2}(\mathbf{A}_c\Delta t)^2+\frac{1}{3!}(\mathbf{A}_c\Delta t)^3 + \dots \end{equation} </p> <p>Using a zero’th order approximation, $\exp(\mathbf{A}_c\Delta t)\approx \mathbf{1}$, yields $\mathbf{Q}_d \approx \Delta t \mathbf{L}_c \mathbf{Q}_c \mathbf{L}_c^{\text{T}}$. Using the first four terms, a 3rd order Taylor series approximation, yields</p> <p>\begin{align} \mathbf{Q}_d&amp;\approx \mathbf{Q}_c\Delta t + (\mathbf{A}_c\mathbf{Q}_c + \mathbf{Q}_c \mathbf{A}_c^\text{T}) \frac{\Delta T^2}{2} +(\mathbf{A}_c^2\mathbf{Q}_c +2\mathbf{A}_c\mathbf{Q}_c\mathbf{A}^\text{T}+\mathbf{Q}(\mathbf{A}_c^\text{T})^2)\frac{\Delta T^3}{6}+ \nonumber \\ &amp;\quad(\mathbf{A}_c^3\mathbf{Q}_c+3\mathbf{A}_c^2\mathbf{Q}_c\mathbf{A}_c^\text{T} +3\mathbf{A}_c\mathbf{Q}_c(\mathbf{A}_c^\text{T})^2+\mathbf{Q}_c(\mathbf{A}_c^\text{T})^3)\frac{T^4}{24}. \end{align} </p> <h2 id="continuous-to-discrete-time-noise-in-a-vacuum">Continuous to Discrete Time Noise “In A Vacuum”</h2> <p>The above discussion is valid for a linear time varying system. This makes sense, for instance, when we linearize a nonlinear system and want to discretize the result. However, in some situations, we <em>already</em> have an exact discretization of the nonlinear system. In this situation, we <em>just</em> want the discrete-time analog of the continuous-time noise on the sensor, without looking at system dynamics - since we already have an exact discretization. For instance, consider the case of angular velocity kinematics with rotations,</p> <p>\begin{align} \dot{\mathbf{C}} &amp;= \mathbf{C} \boldsymbol{\omega}^\times \\ \mathbf{C}_{k+1} &amp;= \mathbf{C} \text{exp}({\Delta t\boldsymbol{\omega}_k}^\times), \end{align}</p> <p>where $\mathbf{C}$ is a cosine matrix describing the orientation of our robot, $\omega$ is an angular velocity measurement, and $\times$ is the cross product operator mapping to the Lie algebra of the space of rotations the $SO(3)$ group.</p> <p>The details are irrelevant and involve Lie groups, which is a big topic in and of itself. I have some <a href="/assets/pdf/notes/lie_group_doc.pdf">notes</a> on them and they are also covered in <d-cite key="barfoot2024state"></d-cite> and <d-cite key="sola2021microlietheorystate"></d-cite>. The point is that we have a real-world example where we have an exact discretization of the system already, without any assumptions on Taylor series truncations.</p> <p>The key aspect of this is that, in the section above, there are <em>two</em> discretizations happening. We are discretizing the linear time varying system <em>as well as</em> the continuous random process. However, in the current situation, we are <em>only</em> interested in the continuous random process. If we take the gyroscope noise with its given continuous-time noise characteristics, and we sample it at a given frequency: What will be the covariance on the resulting discrete-time sampled noise? This tends to be quite confusing, as in process noise derivations such as Sec. 4.7 of <d-cite key="farrell2008navigation"></d-cite> and Sec. 8.1.1 of <d-cite key="simon2006optimal"></d-cite> the linear system and random noise process discretizations are lumped in together. Sec. 8.1.2 of <d-cite key="simon2006optimal"></d-cite> is actually the relevant one for this.</p> <p>Formally, given Gaussian white noise \begin{equation} \mathbf{v}(t) \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_c \delta (t_1-t_2)), \end{equation}</p> <p>what is the “equivalent” discrete-time white noise \begin{equation} \mathbf{v}_k \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_d)? \end{equation}</p> <p>The “equivalent” is in quotes for good reason. For a Gaussian random process, <em>by definition</em>, \begin{equation} \mathbb{E}[\mathbf{v}(t_k) \mathbf{v}(t_k)^{\text{T}}] = \mathbb{E}[\mathbf{v}_k \mathbf{v}_k^{\text{T}}] = \mathbb{E}[\mathbf{Q}_c \delta (t_1-t_2)] = \mathbb{E}[\mathbf{Q}_c \delta (t_k-t_k)] = \mathbf{Q}_c. \end{equation}</p> <p>So, what is $\mathbf{v}_k$? It does not refer to the actual random process variable $\mathbf{v}(t_k)$. Rather, it refers to a separate $\mathbf{v}_k$ that behaves in a way that makes sense for us in an estimator.<br> The widely used (and seemingly correct) answer is \begin{equation} \mathbf{Q}_d = \frac{\mathbf{Q}_c}{\Delta t}. \end{equation}</p> <p>However, tracking down exactly where it comes from and how it is derived is nontrivial. This is the equation given by <a href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model" rel="external nofollow noopener" target="_blank">the IMU noise model section of Kalibr wiki</a>, which itself cites the appendix of J. Crassidis’ sigma point Kalman filtering paper <d-cite key="crassidis2006sigma"></d-cite>. The other source for this seem to be the 3D attitude estimation paper by N. Trawny and S. Roulemiotios <d-cite key="trawny2005indirect"></d-cite>, and Dan Simon’s optimal state estimation book <d-cite key="simon2006optimal"></d-cite>, which is itself the cited source in <d-cite key="trawny2005indirect"></d-cite>.</p> <h3 id="forward-euler-discretization-of-linear-system-and-direct-comparison">Forward Euler Discretization of Linear System And Direct Comparison</h3> <p>This derivation I have seen floating around, but I do not have a direct source for it. It’s the one that makes the most sense though.</p> <p>We take a linear system, discretize it using a forward Euler method, and then compare to the zero’th order approximation from the Linearize Then Discretize approach. We are thus able to separate the discretization of the system matrices from discretization of the random process.</p> <p>Formally, start with the, for now deterministic, linear system as follows. This corresponds to the first step of just discretizing the system matrices, without considering the random process aspect. Thus, for now, $\mathbf{v}$ is deterministic.</p> <p> \begin{align} \dot{\mathbf{x}}&amp;=\mathbf{A}_c \mathbf{x}+\mathbf{L}_c \mathbf{v}, \end{align} </p> <p>a forward Euler scheme with $\dot{\mathbf{x}}\approx \frac{\mathbf{x}_{k+1}-\mathbf{x}_k}{\Delta t}$ yields</p> <p> \begin{align} \mathbf{x}_{k+1}&amp;=\underbrace{(\mathbf{1}+\Delta t\mathbf{A}_c)}_{\mathbf{A}_d} \mathbf{x}_k+ \underbrace{\Delta t \mathbf{L}_c}_{\mathbf{L}_d} \mathbf{v}. \end{align} </p> <p>Now let us remember the fact that $\mathbf{v}$ is actually issued from a random process and consider the system</p> <p> \begin{align} \dot{\mathbf{x}}&amp;=\mathbf{A}_c \mathbf{x}+\mathbf{L}_c \mathbf{v}, \quad \mathbf{v} \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_c \delta (t_1-t_2)), \end{align} </p> <p>such that the equivalent discrete-time system is given by</p> <p> \begin{align} \mathbf{x}_{k+1}&amp;=\underbrace{(\mathbf{1}+\Delta t\mathbf{A}_c)}_{\mathbf{A}_d} \mathbf{x}_k+ \underbrace{\Delta t \mathbf{L}_c}_{\mathbf{L}_d} \mathbf{v}_k, \quad \mathbf{v}_k\sim \mathcal{N}(\mathbf{0}, \mathbf{R}_d), \end{align} </p> <p>where now $\mathbf{v}_k$ is its own Gaussian random variable, with yet to be determined $\mathbf{R}_d$. This is equivalent to</p> <p> \begin{align} \mathbf{x}_{k+1}&amp;=\mathbf{A}_d \mathbf{x}_k+\mathbf{w}_k, \quad \mathbf{w}_k\sim \mathcal{N}(\mathbf{0}, \mathbf{L}_d\mathbf{R}_d\mathbf{L}_d^T), \end{align} </p> <p>$\mathbf{R}_d$ is used for the covariance as $\mathbf{Q}_d$ has been reserved for the $\mathbf{w}_k$ from the Linearize then Discretize section. However, $\mathbf{w}_k$ now corresponds to the $\mathbf{w}_k$ from the Linearize then Discretize section. Using the zero’th order approximation for $\mathbf{Q}_d$ and comparing to the $\mathbf{L}_d\mathbf{R}_d\mathbf{L}_d^T$ expression we obtained here gives</p> <p> \begin{align} \mathbf{L}_d\mathbf{R}_d\mathbf{L}_d^T &amp;= \Delta t \mathbf{L}_c \mathbf{Q}_c \mathbf{L}_c^{\text{T}} \\ \Delta t^2 \mathbf{L}_c\mathbf{R}_d\mathbf{L}_c^T &amp;= \Delta t \mathbf{L}_c \mathbf{Q}_c \mathbf{L}_c^{\text{T}} \\ \mathbf{R}_d &amp;= \mathbf{Q}_c/\Delta t. \end{align} </p> <p>We have reverse engineered the covariance on just the sensor noise itself, $\mathbf{R}_d$, by considering a first-order forward Euler discretization to separate out the system matrix discretization from the random process discretization. We knew what the result of the overall discretization should be from the zeroth order approximation in the Linearize and Discretize section. Then we compared the results of the two approaches and matched the right matrices together.</p> <p>This is the approach that made the most sense to me. However, it is very much roundabout. It does not fully answer the question of “If I just have a nonlinear discrete system with continuous covariances specified for my sensor, what is the discrete time covariance?”. Rather we have to go through linearizations.</p> <h3 id="constant-covariance-estimate-for-a-static-system">Constant Covariance Estimate For A Static System</h3> <p>This is the argument of Sec. 8.1.2 of <d-cite key="simon2006optimal"></d-cite>. I have a few big issues with the chain of logic presented in there. If anyone has good answers to these, please let me know.</p> <p>The argument is essentially as follows. We are trying to isolate the effect of noise, so we take a discrete-time system whose state does not change, and whose measurement is directly equal to the state. This is like taking a gyroscope, putting it on a table (such that the true angular velocity does not change), and considering the resulting measurement. We then say that if we apply the Kalman filter to this system, the error covariance should not change, since there is nothing time-changing about the system. This implies a specific form for the discrete-time covariance, which ends up being the same as the continuous-to-discrete-time conversion we seek. Formally, we start with the scalar system</p> <p> \begin{align} x_k &amp;= x_{k-1} \\ y_k &amp;= x_k + v_k, \quad v_k \sim \mathcal{N}(0, R_d). \end{align} </p> <p>We then apply a Kalman filter to do a correction at a given timestep. There is no uncertainty in the process model, and the correction boils down to linking subsequent covariances as</p> <p> \begin{equation} P_{k+1}=\frac{P_k R_d}{P_k + R_d}. \end{equation} </p> <p>Right off the bat, my first problem with the argument. This only holds for the scalar case. But okay. This then implies that the covariance at timestep $k$ is given by</p> <p> \begin{equation} P_{k}=\frac{P_0 R_d}{kP_0+R_d}, \end{equation} </p> <p>and we want to manipulate this. This is where their argument goes completely off the rails, at least in my understanding. We take the following limit,</p> <p> \begin{equation} \lim_{P_0 \rightarrow \infty}P_{k}=\frac{R}{k}=\frac{R_dT}{k}. \end{equation} </p> <p>And this I completely do not understand. <strong><em>Why</em></strong> ?! Why do we have to push the initial covariance to infinity? How does this make sense? If someone understands please let me know. The argument then proceeds by setting \begin{equation} R_d=\frac{R_c}{T} \end{equation} to make the above expression independent of $T$.</p> <p>To be blunt, I do not think the argument presented in this book for the discrete to continuous time conversion (at least, when purely considering the measurement in Sec. 8.1.2) makes sense. It is possible I missed something major. If I did, please let me know by sending me a mail. That being said, this has a commonality with the previous approach, in that we specify the continuous-time to discrete-time covariance conversion based on behaviour we want from the estimator, and not from a pure mathematical consideration of the random process.</p> <h3 id="conclusion-for-continuous-to-discrete-time-noise-in-a-vacuum">Conclusion For Continuous to Discrete Time Noise “In A Vacuum”</h3> <p>I suspect there is no good explanation based on sampling or integrating the white-noise continuous Gaussian process. One can perhaps do some kind of averaging as mentioned in <a href="https://math.stackexchange.com/questions/3851352/is-there-a-continuous-time-stochastic-process-that-when-sampled-yields-discret" rel="external nofollow noopener" target="_blank">this Stack Overflow post.</a> However, purely in terms of sensor noise for a robot navigation sensor model, it seems there is no mathematically satisfying way to decouple the system dynamics from the random process. The best we can do is the forward Euler discretization comparison method.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2025-03-20-discretization.bib"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'vkorotkine/vkorotkine.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Vassili Korotkine. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/js/diff2html-ui.min.js" integrity="sha256-eU2TVHX633T1o/bTQp6iIJByYJEtZThhF9bKz/DcbbY=" crossorigin="anonymous"></script> <script defer src="/assets/js/diff2html-setup.js?80a6e52ce727518bbd3aed2bb6ba5601" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js" integrity="sha256-MgH13bFTTNqsnuEoqNPBLDaqxjGH+lCpqrukmXc8Ppg=" crossorigin="anonymous"></script> <script defer src="/assets/js/leaflet-setup.js?b6313931e203b924523e2d8b75fe8874" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script defer src="/assets/js/chartjs-setup.js?183c5859923724fb1cb3c67593848e71" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script defer src="/assets/js/echarts-setup.js?738178999630746a8d0cfc261fc47c2c" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script defer src="/assets/js/vega-setup.js?7c7bee055efe9312afc861b128fe5f36" type="text/javascript"></script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/assets/js/typograms.js?062e75bede72543443762dc3fe36c7a5"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?6fb1b44ca0fe71fcbff81b772136a785"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> </body> </html>